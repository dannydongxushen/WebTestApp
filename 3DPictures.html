<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3Däº¤äº’å¼ç…§ç‰‡å¢™</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #upload-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 300px;
        }
        
        #upload-label {
            display: block;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: bold;
        }
        
        #photo-upload {
            width: 100%;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
        }
        
        #upload-status {
            font-size: 14px;
            color: #4ade80;
            margin-bottom: 10px;
        }
        
        #photo-count {
            font-size: 12px;
            color: #ccc;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }
        
        .instruction-item {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .hidden {
            display: none;
        }

        #debug-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #ff4444;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="upload-container">
        <label id="upload-label" for="photo-upload">ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ (æœ€å¤š12å¼ )</label>
        <input type="file" id="photo-upload" accept="image/*" multiple>
        <div id="upload-status">ç­‰å¾…ä¸Šä¼ ç…§ç‰‡...</div>
        <div id="photo-count">å·²ä¸Šä¼ : 0/12 å¼ </div>
    </div>
    
    <div id="instructions">
        <div class="instruction-item">ğŸ–±ï¸ ç‚¹å‡»ç…§ç‰‡: æ”¾å¤§æŸ¥çœ‹</div>
        <div class="instruction-item">ğŸ‘† æ°´å¹³æ»‘åŠ¨/é”®ç›˜å·¦å³é”®: åˆ‡æ¢ç…§ç‰‡</div>
        <div class="instruction-item">ğŸ–±ï¸ åŒå‡»/ESCé”®: è¿”å›ç…§ç‰‡å¢™</div>
    </div>

    <div id="debug-info"></div>

    <!-- å¼•å…¥Three.jså’Œç›¸å…³ç»„ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let photoWall = [];
        let currentPhotoIndex = -1;
        let isViewingPhoto = false;
        let photoFrameGroups = []; // æ”¹ä¸ºå­˜å‚¨æ•´ä¸ªç›¸æ¡†ç»„
        let raycaster, mouse;
        let wall;
        let uploadedPhotos = 0;
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 12);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ è½¨é“æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 8;
            controls.maxDistance = 30;
            
            // åˆå§‹åŒ–å…‰çº¿æŠ•å°„å’Œé¼ æ ‡äº¤äº’
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // åˆ›å»ºå¢™é¢å’Œç¯å…‰
            createWall();
            setupLighting();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬
            setupEventListeners();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();

            updateDebugInfo('åœºæ™¯åˆå§‹åŒ–å®Œæˆ');
        }
        
        // åˆ›å»ºå¢™é¢
        function createWall() {
            // å¢™é¢å‡ ä½•ä½“
            const wallGeometry = new THREE.PlaneGeometry(30, 20);
            
            // å¢™é¢æè´¨ - ç –å¢™çº¹ç†
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            
            wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.rotation.x = -Math.PI / 2;
            wall.position.y = -3;
            wall.receiveShadow = true;
            scene.add(wall);

            updateDebugInfo('å¢™é¢åˆ›å»ºå®Œæˆ');
        }
        
        // è®¾ç½®ç¯å…‰
        function setupLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0xff8844, 0.8, 50);
            pointLight.position.set(-8, 8, 8);
            pointLight.castShadow = true;
            scene.add(pointLight);

            updateDebugInfo('ç¯å…‰è®¾ç½®å®Œæˆ');
        }
        
        // åˆ›å»ºç…§ç‰‡å¢™å¸ƒå±€
        function createPhotoWall() {
            // æ¸…ç©ºç°æœ‰çš„ç›¸æ¡†
            photoFrameGroups.forEach(group => {
                scene.remove(group);
            });
            photoFrameGroups = [];
            photoWall = [];
            uploadedPhotos = 0;

            updateDebugInfo('å¼€å§‹åˆ›å»ºç…§ç‰‡å¢™å¸ƒå±€');
            
            // 3è¡Œ4åˆ—å¸ƒå±€
            const rows = 3;
            const cols = 4;
            const spacingX = 6;
            const spacingY = 4.5;
            const startX = -((cols - 1) * spacingX) / 2;
            const startY = ((rows - 1) * spacingY) / 2;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const index = row * cols + col;
                    
                    // åˆ›å»ºç›¸æ¡†ç»„
                    const frameGroup = new THREE.Group();
                    
                    // åˆ›å»ºç…§ç‰‡å¹³é¢ - ç¨å¾®ç¼©å°ä»¥ç•™å‡ºç›¸æ¡†ç©ºé—´
                    const photoGeometry = new THREE.PlaneGeometry(3.5, 2.5);
                    const photoMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
                    photoMesh.userData = { 
                        type: 'photo', 
                        index: index, 
                        isEmpty: true,
                        originalPosition: new THREE.Vector3(),
                        originalRotation: new THREE.Euler()
                    };
                    
                    // åˆ›å»ºæœ¨è´¨ç›¸æ¡†
                    const frameDepth = 0.3;
                    const frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    // åˆ›å»ºç›¸æ¡†çš„å››ä¸ªè¾¹
                    const frameTop = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.2, frameDepth),
                        frameMaterial
                    );
                    frameTop.position.y = 1.35;
                    
                    const frameBottom = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.2, frameDepth),
                        frameMaterial
                    );
                    frameBottom.position.y = -1.35;
                    
                    const frameLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 2.7, frameDepth),
                        frameMaterial
                    );
                    frameLeft.position.x = -1.85;
                    
                    const frameRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 2.7, frameDepth),
                        frameMaterial
                    );
                    frameRight.position.x = 1.85;
                    
                    // æ·»åŠ åˆ°ç»„
                    frameGroup.add(photoMesh);
                    frameGroup.add(frameTop);
                    frameGroup.add(frameBottom);
                    frameGroup.add(frameLeft);
                    frameGroup.add(frameRight);
                    
                    // è®¡ç®—ä½ç½®
                    frameGroup.position.x = startX + col * spacingX;
                    frameGroup.position.y = startY - row * spacingY;
                    frameGroup.position.z = 0.1; // ç¨å¾®ç¦»å¼€å¢™é¢
                    
                    // ä¿å­˜åŸå§‹ä½ç½®å’Œæ—‹è½¬
                    photoMesh.userData.originalPosition = frameGroup.position.clone();
                    photoMesh.userData.originalRotation = frameGroup.rotation.clone();
                    
                    // æ·»åŠ åˆ°åœºæ™¯
                    scene.add(frameGroup);
                    photoFrameGroups.push(frameGroup);

                    // ä¸ºç…§ç‰‡ç½‘æ ¼æ·»åŠ äº¤äº’å±æ€§
                    photoMesh.userData.parentGroup = frameGroup;
                }
            }

            updateDebugInfo(`ç…§ç‰‡å¢™å¸ƒå±€å®Œæˆï¼Œå…±åˆ›å»º ${rows * cols} ä¸ªç›¸æ¡†ä½ç½®`);
        }
        
        // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
        function handlePhotoUpload(event) {
            const files = event.target.files;
            const maxPhotos = 12;
            
            if (files.length > maxPhotos) {
                alert(`æœ€å¤šåªèƒ½ä¸Šä¼  ${maxPhotos} å¼ ç…§ç‰‡`);
                return;
            }
            
            // é¦–æ¬¡ä¸Šä¼ æ—¶åˆ›å»ºç…§ç‰‡å¢™
            if (photoFrameGroups.length === 0) {
                createPhotoWall();
            }
            
            updateDebugInfo(`å¼€å§‹å¤„ç† ${files.length} å¼ ç…§ç‰‡ä¸Šä¼ `);
            
            let loadedCount = 0;
            
            for (let i = 0; i < Math.min(files.length, maxPhotos); i++) {
                const file = files[i];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // æ‰¾åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨çš„ç›¸æ¡†ä½ç½®
                        const availableIndex = findAvailablePhotoSlot();
                        if (availableIndex === -1) {
                            updateDebugInfo('é”™è¯¯: æ‰¾ä¸åˆ°å¯ç”¨çš„ç›¸æ¡†ä½ç½®');
                            return;
                        }
                        
                        // åˆ›å»ºçº¹ç†
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        
                        // åˆ›å»ºç…§ç‰‡æè´¨
                        const photoMaterial = new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            transparent: true
                        });
                        
                        // è·å–å¯¹åº”çš„ç…§ç‰‡ç½‘æ ¼
                        const photoMesh = photoFrameGroups[availableIndex].children[0];
                        
                        // æ›´æ–°æè´¨
                        photoMesh.material = photoMaterial;
                        photoMesh.userData.isEmpty = false;
                        photoMesh.userData.texture = texture;
                        
                        // å­˜å‚¨ç…§ç‰‡ä¿¡æ¯
                        photoWall[availableIndex] = {
                            texture: texture,
                            material: photoMaterial,
                            originalPosition: photoMesh.userData.originalPosition.clone(),
                            originalRotation: photoMesh.userData.originalRotation.clone(),
                            index: availableIndex
                        };
                        
                        loadedCount++;
                        uploadedPhotos = loadedCount;
                        
                        // æ›´æ–°UI
                        document.getElementById('upload-status').textContent = 
                            `å·²åŠ è½½ ${loadedCount}/${files.length} å¼ ç…§ç‰‡`;
                        document.getElementById('photo-count').textContent = 
                            `å·²ä¸Šä¼ : ${uploadedPhotos}/12 å¼ `;
                        
                        updateDebugInfo(`ç…§ç‰‡ ${loadedCount} åŠ è½½å®Œæˆï¼Œä½ç½®: ${availableIndex}`);
                        
                        if (loadedCount === files.length) {
                            document.getElementById('upload-status').textContent = 
                                `âœ… æ‰€æœ‰ç…§ç‰‡åŠ è½½å®Œæˆ!`;
                            updateDebugInfo(`æ‰€æœ‰ ${files.length} å¼ ç…§ç‰‡åŠ è½½å®Œæˆ`);
                        }
                    };
                    
                    img.onerror = function() {
                        updateDebugInfo(`é”™è¯¯: æ— æ³•åŠ è½½å›¾ç‰‡ ${i}`);
                        loadedCount++;
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = function() {
                    updateDebugInfo(`é”™è¯¯: æ— æ³•è¯»å–æ–‡ä»¶ ${i}`);
                    loadedCount++;
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // æ‰¾åˆ°å¯ç”¨çš„ç…§ç‰‡æ§½ä½
        function findAvailablePhotoSlot() {
            for (let i = 0; i < photoFrameGroups.length; i++) {
                const photoMesh = photoFrameGroups[i].children[0];
                if (photoMesh.userData.isEmpty) {
                    return i;
                }
            }
            return -1;
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // ç…§ç‰‡ä¸Šä¼ 
            document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);
            
            // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆç”¨äºå°„çº¿æ£€æµ‹ï¼‰
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            // è§¦æ‘¸æ»‘åŠ¨äº‹ä»¶
            let touchStartX = 0;
            renderer.domElement.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });
            
            renderer.domElement.addEventListener('touchend', (e) => {
                if (!isViewingPhoto) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const diffX = touchEndX - touchStartX;
                
                if (Math.abs(diffX) > 50) {
                    if (diffX > 0) {
                        showPreviousPhoto();
                    } else {
                        showNextPhoto();
                    }
                }
            });
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // åŒå‡»äº‹ä»¶
            renderer.domElement.addEventListener('dblclick', onDoubleClick);
            
            updateDebugInfo('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseClick(event) {
            if (isViewingPhoto) return;
            
            // æ›´æ–°å°„çº¿
            raycaster.setFromCamera(mouse, camera);
            
            // æ”¶é›†æ‰€æœ‰ç…§ç‰‡ç½‘æ ¼è¿›è¡Œæ£€æµ‹
            const photoMeshes = photoFrameGroups.map(group => group.children[0]);
            const intersects = raycaster.intersectObjects(photoMeshes);
            
            if (intersects.length > 0) {
                const photoMesh = intersects[0].object;
                if (!photoMesh.userData.isEmpty) {
                    currentPhotoIndex = photoMesh.userData.index;
                    updateDebugInfo(`ç‚¹å‡»ç…§ç‰‡: ${currentPhotoIndex}`);
                    zoomPhoto(currentPhotoIndex);
                }
            }
        }
        
        function onDoubleClick(event) {
            if (isViewingPhoto) {
                updateDebugInfo('åŒå‡»è¿”å›ç…§ç‰‡å¢™');
                returnPhotoToWall();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // æ”¾å¤§æ˜¾ç¤ºç…§ç‰‡
        function zoomPhoto(index) {
            if (index < 0 || photoWall[index] === undefined) {
                updateDebugInfo(`é”™è¯¯: ç…§ç‰‡ç´¢å¼• ${index} æ— æ•ˆ`);
                return;
            }
            
            isViewingPhoto = true;
            currentPhotoIndex = index;
            
            const frameGroup = photoFrameGroups[index];
            const photoMesh = frameGroup.children[0];
            
            updateDebugInfo(`æ”¾å¤§ç…§ç‰‡ ${index}`);
            
            // åŠ¨ç”»åˆ°ç›¸æœºå‰æ–¹
            const targetPosition = new THREE.Vector3(0, 0, 5);
            const targetRotation = new THREE.Euler(0, 0, 0);
            
            // åŠ¨ç”»åˆ°æŒ‡å®šä½ç½®
            animateToPosition(frameGroup, targetPosition, targetRotation, 1000);
            
            // éšè—å…¶ä»–ç…§ç‰‡
            photoFrameGroups.forEach((group, i) => {
                if (i !== index) {
                    group.visible = false;
                }
            });
            
            // ç¦ç”¨è½¨é“æ§åˆ¶
            controls.enabled = false;
        }
        
        // æ˜¾ç¤ºä¸‹ä¸€å¼ ç…§ç‰‡
        function showNextPhoto() {
            if (!isViewingPhoto) return;
            
            let nextIndex = (currentPhotoIndex + 1) % photoFrameGroups.length;
            let attempts = 0;
            
            // å¯»æ‰¾ä¸‹ä¸€å¼ æœ‰ç…§ç‰‡çš„ä½ç½®
            while (photoWall[nextIndex] === undefined && attempts < photoFrameGroups.length) {
                nextIndex = (nextIndex + 1) % photoFrameGroups.length;
                attempts++;
            }
            
            if (photoWall[nextIndex] !== undefined && nextIndex !== currentPhotoIndex) {
                updateDebugInfo(`åˆ‡æ¢åˆ°ä¸‹ä¸€å¼ ç…§ç‰‡: ${nextIndex}`);
                
                // å…ˆå°†å½“å‰ç…§ç‰‡è¿”å›
                const currentFrameGroup = photoFrameGroups[currentPhotoIndex];
                animateToPosition(
                    currentFrameGroup, 
                    photoWall[currentPhotoIndex].originalPosition, 
                    photoWall[currentPhotoIndex].originalRotation, 
                    500
                );
                
                // ç„¶åæ”¾å¤§ä¸‹ä¸€å¼ 
                setTimeout(() => {
                    currentPhotoIndex = nextIndex;
                    zoomPhoto(nextIndex);
                }, 500);
            }
        }
        
        // æ˜¾ç¤ºä¸Šä¸€å¼ ç…§ç‰‡
        function showPreviousPhoto() {
            if (!isViewingPhoto) return;
            
            let prevIndex = (currentPhotoIndex - 1 + photoFrameGroups.length) % photoFrameGroups.length;
            let attempts = 0;
            
            // å¯»æ‰¾ä¸Šä¸€å¼ æœ‰ç…§ç‰‡çš„ä½ç½®
            while (photoWall[prevIndex] === undefined && attempts < photoFrameGroups.length) {
                prevIndex = (prevIndex - 1 + photoFrameGroups.length) % photoFrameGroups.length;
                attempts++;
            }
            
            if (photoWall[prevIndex] !== undefined && prevIndex !== currentPhotoIndex) {
                updateDebugInfo(`åˆ‡æ¢åˆ°ä¸Šä¸€å¼ ç…§ç‰‡: ${prevIndex}`);
                
                // å…ˆå°†å½“å‰ç…§ç‰‡è¿”å›
                const currentFrameGroup = photoFrameGroups[currentPhotoIndex];
                animateToPosition(
                    currentFrameGroup, 
                    photoWall[currentPhotoIndex].originalPosition, 
                    photoWall[currentPhotoIndex].originalRotation, 
                    500
                );
                
                // ç„¶åæ”¾å¤§ä¸Šä¸€å¼ 
                setTimeout(() => {
                    currentPhotoIndex = prevIndex;
                    zoomPhoto(prevIndex);
                }, 500);
            }
        }
        
        // è¿”å›ç…§ç‰‡åˆ°å¢™ä¸Š
        function returnPhotoToWall() {
            if (!isViewingPhoto || currentPhotoIndex < 0) return;
            
            const frameGroup = photoFrameGroups[currentPhotoIndex];
            
            updateDebugInfo(`è¿”å›ç…§ç‰‡ ${currentPhotoIndex} åˆ°å¢™é¢`);
            
            // åŠ¨ç”»è¿”å›åŸå§‹ä½ç½®
            animateToPosition(
                frameGroup, 
                photoWall[currentPhotoIndex].originalPosition, 
                photoWall[currentPhotoIndex].originalRotation, 
                1000
            );
            
            // æ˜¾ç¤ºæ‰€æœ‰ç…§ç‰‡
            setTimeout(() => {
                photoFrameGroups.forEach(group => {
                    group.visible = true;
                });
                
                isViewingPhoto = false;
                controls.enabled = true;
                currentPhotoIndex = -1;
            }, 1000);
        }
        
        // åŠ¨ç”»åˆ°æŒ‡å®šä½ç½®
        function animateToPosition(object, targetPosition, targetRotation, duration) {
            const startPosition = object.position.clone();
            const startRotation = object.rotation.clone();
            const startTime = Date.now();
            
            function update() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const easeProgress = easeInOutCubic(progress);
                
                // æ›´æ–°ä½ç½®
                object.position.lerpVectors(startPosition, targetPosition, easeProgress);
                
                // æ›´æ–°æ—‹è½¬
                object.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * easeProgress;
                object.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * easeProgress;
                object.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }
        
        // ç¼“åŠ¨å‡½æ•°
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        function updateDebugInfo(message) {
            document.getElementById('debug-info').textContent = `è°ƒè¯•: ${message}`;
            console.log(`DEBUG: ${message}`);
        }
        
        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') {
                showPreviousPhoto();
            } else if (event.key === 'ArrowRight') {
                showNextPhoto();
            } else if (event.key === 'Escape') {
                returnPhotoToWall();
            }
        });
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ§åˆ¶å™¨
            if (controls.enabled) {
                controls.update();
            }
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        init();
    </script>
</body>
</html>